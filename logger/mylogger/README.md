## 自定义实现Logger功能

### 控制打印级别
### 日志切割
日志切割是指当应用或系统的日志文件达到设定的触发条件（如按照一定的时间周期：每天，按照大小：500MB），对其进行切割/分割处理，类似截断处理，**把原本容量比较大的日志文件"劫走"转存为另外一个日志文件留存归档，这一刻之后产生的日志，继续输出到文件头被重置为0的日志文件中**。

变化的部分：日志文件的容量（瘦身变小），日志文件的个数（多出一份被切割下的历史日志）

#### 原因
在线应用（包括操作系统）在长期运行过程中，会产生很多过程日志记录，通常是应用程序记录的一些对系统管理员或者程序开发者有用的信息的文件，诸如正在执行什么、发生了什么错误等一系列信息。

随着日志记录的不断积累，日志文件越来越大，随着时间推移，会带来以下弊病：

日志文件占用的硬盘空间越来越大
日志文件太大，达到GB级别后查看内容太耗时，要追踪错误等非常不方便

#### 基本需求：
- 应用层面：不能影响应用的正常运行
- 数据层面：日志文件名不变，不丢失日志或在可接受的范围内丢失极少日志切割过程中不影响应用继续输出记录日志
- 日志容量层面：切割后的新的日志文件从空文件开始重新记录（容量和文件头被重置），便于后续查询使用
- 日志归档：切割后老旧日志方便归档压缩处理，（文件名加上日期后缀等）分割后的老旧日志**可按照保存周期轮询删除**
- 管理维护层面： 自动化周期性进行，周而复始


#### 实现思路
思路1(myLogger实现使用思路)： 
重命名移走旧（需要被切割的）的日志文件，同时生成一个新的日志文件(文件名与切割之前保持一致)，但是需要确保应用可以指向新的文件句柄新的日志文件当然从0开始写。

思路2：
拷贝并重命名一份现有日志文件，把现有日志文件cp一份为另外的文件名，同时非常快速地把现有日志文件清空但不改变现有日志文件的文件句柄。这样日志文件的文件名和句柄都没有变化，只是内容已经被清空，也是从0开始继续写入。

### 日志滚动（log rotation）
删除时间久远的日志文件

不变的部分：日志文件名不变
### 打印调用堆栈：返回函数名、文件名、行号
runtime.caller(n)   n表示第几层
### encoder的方式可以有json和text两种

### 实现结构化日志
将日志结构化为组件，例如：时间戳、级别、消息、调用堆栈
形式为json形式

目的：使得查找内容更加方便


不丢日志应该是：比如程序崩溃了，是否尽可能做到不丢日志?


> 日志切割和滚动实现：每次调用debug/info函数时，判断当前的日期和之前的日期是否一致，比如说初始化的时候获得一年当中的第几天，当调用debug/info发现日期不同，就触发日志切分