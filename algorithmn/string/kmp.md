## kmp算法

核心思想：
利用匹配失败后的信息
尽量减少模式串与主串的匹配
以达到快速匹配的目的

### 字符串前缀
字符串：ababacb
前缀集合：{a, ab, aba, abab, ababa, ababac}

### 字符串后缀
字符串：ababacb
后缀集合: {b, cb, acb, bacb, abacb, babacb}

### 暴力算法和kmp区别
i指向主串中的A子串
j指向模式串（需要匹配的子串）——B串

暴力算法i，j都要回溯
kmp只回溯j： 因为当前失败的信息还表示，前面的字符都匹配成功了

### kmp只回溯j原理
当且仅当主串中A子串后缀集合与B串前缀集合有交集时，i不需要回溯，只将j回溯


### kmp算法
重点：找到j回溯到哪个位置 
我们就要找到A子串后缀集合与B串的前缀集合的交集里：最长的那个元素，最长的元素使得模式串后移的最少且在已知信息中匹配的最多
最长元素的长度：就是j指针回溯的位置

而A子串后缀集合与B串前缀集合的交集=模式串的前缀集合与它本身后缀集合的交集（因为匹配失败时，A子串和B串前面部分的子串是相同的，我们只需要找到前面子串的前缀集合和后缀集合的交集即可）

**所以j指针回溯的位置 = B串的最长公共前后缀**


**在A子串、B串匹配之前，就可以通过B串计算回溯位置，存在一个数组next中，next[i]就是B[1]~B[i]的最长公共前后缀的长度**

具体流程：
1. i，j初始化为0
2. 如果A[i+1]=B[j+1]，i++， j++继续匹配
3. 如果A[i+1]!=B[j+1]，回溯j到next[j]，直到A[i+1]=B[j+1]（这里有一种情况，B串需要移动到i后面，也就是j回溯到0也不能满足使得A[i+1]=B[j+1]）
4. 当j=0时，忽略j，增加i，直到A[i+1]=B[j+1]
5. 当j=m（匹配成功），输出位置，继续匹配

构建next前缀表相当于自己和自己匹配并记录最长公共前后缀

1. 如果字符匹配：next[i] = j + 1，j是B串前缀的指针
2. 如果字符不匹配：回溯j指针，j=next[j]，直到匹配成功