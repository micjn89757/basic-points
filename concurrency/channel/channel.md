## channel
本质就是一个环形队列, 遵循先入先出
goroutine是Go程序并发的执行体, channel就是它们之间的连接，可以让一个goroutine发送特定值到另一个goroutine


## range接受值
for range循环从通道中接受值，当通道关闭后，会将还在通道中的值读取完并自动退出循环

## 单向通道
<- chan int 只接受不能发送
chan <- int 只发送不能接受
这种限制会在编译阶段进行检测

正常通道(全向)可以转换为单向通道，反之不行

## 注意
一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。

==关闭后的通道有以下特点==：
- 对一个关闭的通道再发送值就会导致 panic。
- 对一个关闭的通道进行接收会一直获取值直到通道为空。
- 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。
- 关闭一个已经关闭的通道会导致 panic。


v, ok := <- ch
channel被关闭并且channel为空，ok才为false

目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能通过len(ch)的操作来判断通道是否被关闭


